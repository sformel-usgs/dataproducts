<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.353">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Stephen Formel">

<title>Update to Webb et al.&nbsp;2010 [Figure 2]</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="sformel_notebook_webb_et_al_2010_figure2_files/libs/clipboard/clipboard.min.js"></script>
<script src="sformel_notebook_webb_et_al_2010_figure2_files/libs/quarto-html/quarto.js"></script>
<script src="sformel_notebook_webb_et_al_2010_figure2_files/libs/quarto-html/popper.min.js"></script>
<script src="sformel_notebook_webb_et_al_2010_figure2_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="sformel_notebook_webb_et_al_2010_figure2_files/libs/quarto-html/anchor.min.js"></script>
<link href="sformel_notebook_webb_et_al_2010_figure2_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="sformel_notebook_webb_et_al_2010_figure2_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="sformel_notebook_webb_et_al_2010_figure2_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="sformel_notebook_webb_et_al_2010_figure2_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="sformel_notebook_webb_et_al_2010_figure2_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#background" id="toc-background" class="nav-link active" data-scroll-target="#background">Background</a></li>
  <li><a href="#purpose" id="toc-purpose" class="nav-link" data-scroll-target="#purpose">Purpose</a>
  <ul class="collapse">
  <li><a href="#downloading-the-data" id="toc-downloading-the-data" class="nav-link" data-scroll-target="#downloading-the-data">Downloading the data</a></li>
  </ul></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Update to Webb et al.&nbsp;2010 [Figure 2]</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Stephen Formel </p>
          </div>
  </div>
    
  
    
  </div>
  

</header>

<div class="cell">
<div class="cell-output cell-output-stderr">
<pre><code>
Attaching package: 'dplyr'</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>The following objects are masked from 'package:stats':

    filter, lag</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>The following objects are masked from 'package:base':

    intersect, setdiff, setequal, union</code></pre>
</div>
</div>
<section id="background" class="level2">
<h2 class="anchored" data-anchor-id="background">Background</h2>
<p>This is based on a fork of the repo of https://github.com/iobis/dataproducts, which was a re-analysis of OBIS data to recreate Figure 2 from Webb et al.&nbsp;2010 (https://doi.org/10.1371/journal.pone.0010223)</p>
<p>The original <a href="https://doi.org/10.1371/journal.pone.0010223.g002">Figure 2 from Webb et al.</a> represented the “global distribution [of OBIS record] within the water column of recorded marine biodiversity.” The original caption is:</p>
<blockquote class="blockquote">
<p><br>
The horizontal axis splits the oceans into five zones on the basis of depth (see <a href="https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0010223#pone-0010223-t001">Table 1</a>), with the width of each zone on this axis proportional to its global surface area. The vertical axis is ocean depth, on a linear scale. This means that area on the graph is proportional to volume of ocean. For instance, in the deep sea each cell of 200m depth represents <em>c.</em> 3.5×10<sup>6</sup> km<sup>3</sup> (see cell drawn separately for scale). The number of records in each cell (each unique combination of sample and bottom depth, following the scheme in <a href="https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0010223#pone-0010223-t001">Table 1</a>) is standardised to the volume of water represented by that cell, and then log<sub>10</sub>-transformed. The inset shows in greater detail the continental shelf and slope, where the majority of records are found.</p>
</blockquote>
<p>The methods section of the paper describes the downloaded data from OBIS, after filtering, to consist of, <em>“a working dataset of 6987676 individual records sampled from 172012 unique locations in three-dimensional (latitude, longitude, sample depth) space.”</em></p>
<p>At the time of writing, the authors describe OBIS of including &gt; 22 million records. In November 2018, Pieter Provoost recreated this figure, <code>apparently revising a potential error in the analysis</code> although his figure was based on ~ 30 million records, after filtering; about 3 times as many records as available to Webb et al.&nbsp;As of 2023-10-26, OBIS has grown to include <code>generate this code</code> unfiltered records.</p>
</section>
<section id="purpose" class="level2">
<h2 class="anchored" data-anchor-id="purpose">Purpose</h2>
<p>Here, I update the work of Pieter Provoost to increase the documentation and take advantage of relatively new OBIS features (e.g.&nbsp;data delivered in a parquet format), and code, to create a figure that can be more easily reproduced, iterated, and customized for spatial, temporal and taxonomic needs.</p>
<section id="downloading-the-data" class="level3">
<h3 class="anchored" data-anchor-id="downloading-the-data">Downloading the data</h3>
<p>Although one of the advantages of a parquet file is the ability to call it and work with it in a cloud environment, on my local connection (I work remotely), this is too slow. I find it is much more efficient to download a local copy, which can be removed after analysis.</p>
<p>Download the local copy, using some prior detective work to programatically find the URI for the most recent parquet file. First, scrape the OBIS API exports log for the parquet files. They will be delivered newest to oldest. Create a metadata file of what you are downloading, for provenance.</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>$id
[1] "763b37f9-e69c-46aa-b84d-05f3fd3a337d"

$created
[1] "2023-07-27T16:22:01.132Z"

$creator
[1] "Ocean Biodiversity Information System (OBIS)"

$title
[1] "Full OBIS export 2023-07-26"

$modified
NULL

$doi
NULL

$abstract
NULL

$occurrence_records
NULL

$complete
[1] TRUE

$s3path
[1] "exports/obis_20230726.parquet"

$type
[1] "parquet"</code></pre>
</div>
</div>
<p>Then, check if the current version is already downloaded. If not, grab the filename from the previous codeblock, and paste it together with the root URI, to get the full URI and download the file, after setting R options to avoid a timeout. Currently, the file is about 16 GB.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>